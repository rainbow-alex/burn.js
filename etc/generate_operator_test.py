#!/usr/bin/env python3
import os
import sys
import time
import subprocess
from itertools import count
import re

#
# evaluation helpers
#

class BurnEvalError (Exception): pass

def eval_burn( source ):
	if "burn" in source:
		source = "import burn\n" + source
	process = subprocess.Popen(
		"../src/bin/burn.js --tolerant -",
		stdin = subprocess.PIPE,
		stdout = subprocess.PIPE,
		stderr = subprocess.PIPE,
		shell = True
	)
	process.stdin.write( source.encode( "utf-8" ) )
	process.stdin.close()
	exit_status = process.wait( 1 )
	if exit_status != 0:
		raise BurnEvalError()
	stdout = process.stdout.read().decode( "utf-8" )
	return stdout

def eval_burn_expression( expression ):
	return eval_burn( "print " + expression )[:-1]

def eval_burn_expressions( expressions ):
	return eval_burn( "".join( "print %s\n" % e for e in expressions ) ).splitlines()

#
# operator definitions
#

class Op:
	def __init__( self, name, symbol ):
		self.name = name
		self.symbol = symbol

class BinOp (Op): pass
class UnOp (Op): pass

OPS = [
	BinOp( "or", "or" ),
	BinOp( "and", "and" ),
	UnOp( "not", "not" ),
	BinOp( "is", "is" ),
	BinOp( "eq", "==" ),
	BinOp( "neq", "!=" ),
	BinOp( "lt", "<" ),
	BinOp( "gt", ">" ),
	BinOp( "lteq", "<=" ),
	BinOp( "gteq", ">=" ),
	BinOp( "add", "+" ),
	BinOp( "sub", "-" ),
]

UNARY_OPS = list( filter( lambda op: isinstance( op, UnOp ), OPS ) )
BINARY_OPS = list( filter( lambda op: isinstance( op, BinOp ), OPS ) )

def get_op( name ):
	for op in OPS:
		if op.name == name:
			return op
	else:
		assert False

#
# output helpers
#

stderr_newline = True

def stderr_print( text ):
	stderr_end_line()
	print( text, end="", file=sys.stderr )
	sys.stderr.flush()
	global stderr_newline
	stderr_newline = False

def stderr_tick():
	print( ".", end="", file=sys.stderr )
	sys.stderr.flush()
	global stderr_newline
	stderr_newline = False

def stderr_end_line():
	global stderr_newline
	if not stderr_newline:
		print( file=sys.stderr )
	stderr_newline = True

def print_test( name, source, stdout ):
	assert source
	print()
	print( "%s.burn:" % name )
	if "burn" in source:
		print( "\timport burn" )
	for l in source.splitlines():
		print( "\t%s" % l )
	print()
	print( "$ burn --tolerant %s.burn" % name )
	print( "	* stdout" )
	for l in stdout.splitlines():
		print( "\t\t%s" % l )

#
# generating routines
#

class Break (Exception): pass

os.chdir( os.path.dirname( __file__ ) )
assert len( sys.argv ) >= 2

print( "// generated by `" + " ".join( sys.argv ) + "`" )

if sys.argv[1] == "result":
	assert len( sys.argv ) == 3
	
	op = get_op( sys.argv[2] )
	values = [
		"nothing",
		"true", "false",
		"0", "2", "-2",
		"0.0", "2.0",  "-0.5",
		"\"\"", "\"foo\"",
		"function(){}",
		"Something",
		"burn"
	]
	
	# extra numbers to expose arithmetic operator edge cases
	if op.name in [ "add", "sub", "mul", "div" ]:
		values += [ "3", "8", "0.3", "0.33333333333", "0.7" ]
	
	if isinstance( op, BinOp ):
		for test_no, v1 in zip( count(1), values ):
			stderr_print( "%s %s ? " % ( v1, op.symbol ) )
			source = ""
			stdout = ""
			for i, v2 in zip( count(1), values ):
				stderr_tick()
				expression = "%s %s %s" % ( v1, op.symbol, v2 )
				try:
					result_type, output = eval_burn_expressions( ( "repr(%s)" % expression, expression ) )
				except BurnEvalError:
					pass
				else:
					test = "$r%s" % i
					if result_type == "<Float>":
						lower_bound = "%.4f" % ( round( float( output ), 4 ) - 0.0001 )
						upper_bound = "%.4f" % ( round( float( output ), 4 ) + 0.0001 )
						test = "( %s < $r%s ) and ( $r%s < %s )" % ( lower_bound, i, i, upper_bound )
						output = "true"
					source += "let $r%s = %s\nprint repr( $r%s )\nprint %s\n" % ( i, expression, i, test )
					stdout += "%s\n%s\n" % ( result_type, output )
			if source:
				print_test( "%s_result_%s" % ( op.name, test_no ), source, stdout )
			stderr_end_line()
		
	else:
		assert isinstance( op, UnOp )
		source = ""
		stdout = ""
		for i, v in zip( count(1), values ):
			stderr_tick()
			expression = "%s %s" % ( op.symbol, v )
			try:
				result_type, output = eval_burn_expressions( ( "repr(%s)" % expression, expression ) )
			except BurnEvalError:
				pass
			else:
				source += "let $r%s = %s\nprint repr( $r%s )\nprint $r%s\n" % ( i, expression, i, i )
				stdout += "%s\n%s\n" % ( result_type, output )
		print_test( "%s_result" % op.name, source, stdout )
		stderr_end_line()
	
elif sys.argv[1] == "type_error":
	assert len( sys.argv ) == 3
	
	op = get_op( sys.argv[2] )
	values = [
		"nothing",
		"true",
		"1",
		"1.0",
		"\"foo\"",
		"function(){}",
		"Something",
		"burn"
	]
	
	if isinstance( op, BinOp ):
		source = ""
		stdout = ""
		for v1 in values:
			stderr_print( "%s %s ? " % ( v1, op.symbol ) )
			for v2 in values:
				stderr_tick()
				expression = "%s %s %s" % ( v1, op.symbol, v2 )
				try:
					eval_burn_expression( expression )
				except BurnEvalError:
					source += "try { %s } catch TypeError $e { print \"TypeError\" }\n" % expression
					stdout += "TypeError\n"
					break
			stderr_end_line()
		if source:
			print_test( "%s_type_error" % op.name, source, stdout )
		
	else:
		assert isinstance( op, UnOp )
		source = ""
		stdout = ""
		for i, v in zip( count(1), values ):
			stderr_tick()
			expression = "%s %s" % ( op.symbol, v )
			try:
				eval_burn_expression( expression )
			except BurnEvalError:
				source += "try { %s } catch TypeError $e { print \"TypeError\" }\n" % expression
				stdout += "TypeError\n"
		stderr_end_line()
		if source:
			print_test( "%s_type_error" % op.name, source, stdout )
	
elif sys.argv[1] == "precedence":
	assert len( sys.argv ) == 3
	
	op1 = get_op( sys.argv[2] )
	values = [ "true", "false" ]
	
	if isinstance( op1, BinOp ):
		for op2 in BINARY_OPS:
			stderr_print( "%s VS %s " % ( op1.symbol, op2.symbol ) )
			try:
				for v1 in values:
					for v2 in values:
						for v3 in values:
							stderr_tick()
							e1 = "( %s %s %s ) %s %s" % ( v1, op1.symbol, v2, op2.symbol, v3 )
							e2 = "%s %s ( %s %s %s )" % ( v1, op1.symbol, v2, op2.symbol, v3 )
							e = "%s %s %s %s %s" % ( v1, op1.symbol, v2, op2.symbol, v3 )
							try:
								r1, r2, r = eval_burn_expressions( ( e1, e2, e ) )
							except BurnEvalError:
								pass
							else:
								if r1 != r2:
									print_test(
										"%s_%s" % ( op1.name, op2.name ),
										"\n".join( "print %s" % e for e in (e1, e2, e) ),
										"\n".join( (r1, r2, r) )
									)
									raise Break()
			except Break:
				pass
			stderr_end_line()
	
	else:
		assert isinstance( op1, UnOp )
		for op2 in BINARY_OPS:
			stderr_print( "%s VS %s " % ( op1.symbol, op2.symbol ) )
			try:
				for v1 in values:
					for v2 in values:
						stderr_tick()
						e1 = "( %s %s ) %s %s" % ( op1.symbol, v1, op2.symbol, v2 )
						e2 = "%s ( %s %s %s )" % ( op1.symbol, v1, op2.symbol, v2 )
						e = "%s %s %s %s" % ( op1.symbol, v1, op2.symbol, v2 )
						try:
							r1, r2, r = eval_burn_expressions( ( e1, e2, e ) )
						except BurnEvalError:
							pass
						else:
							if r1 != r2:
								print_test(
									"%s_%s" % ( op1.name, op2.name ),
									"".join( "print %s\n" % e for e in (e1, e2, e) ),
									"".join( "%s\n" % r for r in (r1, r2, r) )
								)
								raise Break()
			except Break:
				pass
			stderr_end_line()
	
else:
	assert False
