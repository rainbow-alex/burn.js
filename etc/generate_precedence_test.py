#!/usr/bin/env python3
import os
import sys
import subprocess

class Op:
	def __init__( self, name, symbol ):
		self.name = name
		self.symbol = symbol

class BinOp (Op): pass
class UnOp (Op): pass

operators = [
	BinOp( "or", "or" ),
	BinOp( "and", "and" ),
	UnOp( "not", "not" ),
	BinOp( "is", "is" ),
	BinOp( "is_not", "is not" ),
	BinOp( "eq", "==" ),
	BinOp( "neq", "!=" ),
	BinOp( "lt", "<" ),
	BinOp( "gt", ">" ),
	BinOp( "lteq", "<=" ),
	BinOp( "gteq", ">=" ),
	BinOp( "add", "+" ),
	BinOp( "sub", "-" ),
	BinOp( "mul", "*" ),
	BinOp( "div", "/" ),
	BinOp( "union", "|" ),
	BinOp( "intersection", "&" ),
]

values = [
	"nothing",
	"true", "false",
	"0", "2", "4",
]

os.chdir( os.path.dirname( __file__ ) )
assert len( sys.argv ) == 2

for op1 in operators:
	if op1.name == sys.argv[1]:
		break
else:
	assert False

print( "// generated by `" + " ".join( sys.argv ) + "`" )

for op2 in operators:
	print( ".", end="", file=sys.stderr )
	sys.stderr.flush()
	
	print()
	
	if isinstance( op2, UnOp ):
		print( "// GREP_ME precedence %s %s" % ( op1.name, op2.name ) )
		continue
	
	# generate expressions combining these operators
	expressions = []
	if isinstance( op1, BinOp ):
		for v1 in values:
			for v2 in values:
				for v3 in values:
					expressions.append( "( %s %s %s ) %s %s" % ( v1, op1.symbol, v2, op2.symbol, v3 ) )
					expressions.append( "%s %s ( %s %s %s )" % ( v1, op1.symbol, v2, op2.symbol, v3 ) )
					expressions.append( "%s %s %s %s %s" % ( v1, op1.symbol, v2, op2.symbol, v3 ) )
	else:
		for v1 in values:
			for v2 in values:
				expressions.append( "( %s %s ) %s %s" % ( op1.symbol, v1, op2.symbol, v2 ) )
				expressions.append( "%s ( %s %s %s )" % ( op1.symbol, v1, op2.symbol, v2 ) )
				expressions.append( "%s %s %s %s" % ( op1.symbol, v1, op2.symbol, v2 ) )
	
	# build some source code with these expressions ...
	source = "".join(
		"try { print %s } catch TypeError $e { print \"TypeError\" }\n" % e
		for e in expressions
	)
	
	# ... and run it
	process = subprocess.Popen(
		"../src/bin/burn.js -",
		stdin = subprocess.PIPE,
		stdout = subprocess.PIPE,
		stderr = subprocess.PIPE,
		shell = True
	)
	process.stdin.write( source.encode( "utf-8" ) )
	process.stdin.close()
	exit_status = process.wait( 1 )
	
	# a syntax error occurred, a syntax error test should cover this case
	if exit_status != 0:
		print( "%s_%s.burn:" % ( op1.name, op2.name ) )
		print( "	%s" % expressions[2] )
		print( "$ $BURN %s_%s.burn" % ( op1.name, op2.name ) )
		print( "	* exit status nonzero" )
		continue
	
	outputs = process.stdout.read().decode( "utf-8" ).splitlines()
	
	# find two outputs that differ, preferring actual values over TypeErrors
	for i in range( 0, len( expressions ), 3 ):
		e1, e2, e = expressions[ i : i+3 ]
		o1, o2, o = outputs[ i : i+3 ]
		if o1 == "TypeError" or o2 == "TypeError":
			continue
		elif "." in o1 or "." in o2:
			continue
		if o1 != o2:
			break
	else:
		for i in range( 0, len( expressions ), 3 ):
			e1, e2, e = expressions[ i : i+3 ]
			o1, o2, o = outputs[ i : i+3 ]
			if "." in o1 or "." in o2:
				continue
			elif o1 != o2:
				break
		else:
			print( "// GREP_ME precedence %s %s" % ( op1.name, op2.name ) )
			continue
	
	# print out a test with these values
	def print_assertion( e, o ):
		if o == "TypeError":
			print( "	test.assert_throws( function() { %s }, TypeError )" % e )
		else:
			print( "	assert( ( %s ) == %s )" % ( e, o ) )
	print( "%s_%s.burn:" % ( op1.name, op2.name ) )
	if o1 == "TypeError" or o2 == "TypeError":
		print( "	import test" )
	print_assertion( e1, o1 )
	print_assertion( e2, o2 )
	print_assertion( e, o )
	print( "	" )
	print( "$ $BURN %s_%s.burn" % ( op1.name, op2.name ) )

print( file=sys.stderr )
